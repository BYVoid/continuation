var util = require('util');
var traverse = require('./lib/traverse');
var helpers = require('./lib/helpers');

var sourceMap;

exports.compile = function (code, options) {
  if (!options) {
    options = {
      sourceMap: false
    };
  }
  
  var indent = '  ';
  if (options.indent) {
    indent = options.indent;
  }
  
  if (!options.force && options.explicit && code.indexOf('use continuation') === -1) {
    //Mark literal not found in code
    return code;
  }
  
  //Reset helper
  helpers.reset();
  
  //Parse code
  var parser = require('./lib/parser');
  var ast = parser.parse(code);
  
  if (options.explicit) {
    //Traverse ast and find explicit compilation mark
    if (!findExplicitMark(ast)) {
      return code;
    }
  }
  
  var meta = require('./package.json');
  var mark = '/* Generated by Continuation.js v' + meta.version + ' */';
  
  //Tranformation not needed
  if (!options.force && !transformNeeded(ast)) {
    return code + '\n' + mark;
  }
  
  traverse(ast, function (node) {
    return node.normalize ? node.normalize() : node;
  });
  //console.error(util.inspect(ast, false, null, true)); //debug
  ast.transform();
  //console.error(util.inspect(ast, false, null, true)); //debug

  //Generate code
  var escodegen = require('escodegen');
  //ast = escodegen.attachComments(ast, ast.comments, ast.tokens); //debug
  var genOptions = {
    format: {
      indent: {
        style: indent,
        base: 0
      }
    },
    comment: true
  };
  code = escodegen.generate(ast, genOptions);
  
  //Generate source map
  if (options.sourceMap) {
    genOptions.sourceMap = 'continuation.js';
    sourceMap = JSON.parse(escodegen.generate(ast, genOptions));
  }
  return code + '\n' + mark;
};

exports.getSourceMap = function (file, sources) {
  sourceMap.file = file;
  sourceMap.sources = sources;
  return JSON.stringify(sourceMap);
};

var findExplicitMark = function (ast) {
  var found = false;
  traverse(ast, function (node) {
    if (node.type === 'ExpressionStatement') {
      if (node.expression.type === 'Literal' && node.expression.value === 'use continuation') {
        found = true;
      }
    }
    return node;
  });
  return found;
};

var transformNeeded = function (ast) {
  var needed = false;
  traverse(ast, function (node) {
    if (node.type === 'CallExpression') {
      node.arguments.forEach(function (argument) {
        if (argument.type === 'CallExpression' && argument.callee.type === 'Identifier') {
          if (argument.callee.name === helpers.contName || argument.callee.name === helpers.obtainName) {
            needed = true;
          }
        }
      });
    }
    return node;
  });
  return needed;
};
